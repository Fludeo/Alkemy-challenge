"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveFunctionParameters = void 0;
var AbstractResolver_1 = __importDefault(require("./resolvers/AbstractResolver"));
var RawValueResolver_1 = __importDefault(require("./resolvers/RawValueResolver"));
var errors_1 = require("./errors");
var DefinitionName_1 = require("./DefinitionName");
/**
 * Dependency injection container
 */
var DIContainer = /** @class */ (function () {
    function DIContainer() {
        this.resolvers = {};
        this.resolved = {};
    }
    /**
     * Resolves dependency by name
     * @param dependencyName - DefinitionName name of the dependency. String or class name.
     * @param parentDeps - array of parent dependencies (used to detect circular dependencies)
     */
    DIContainer.prototype.get = function (dependencyName, parentDeps) {
        if (parentDeps === void 0) { parentDeps = []; }
        var name = (0, DefinitionName_1.definitionNameToString)(dependencyName);
        if (!(name in this.resolvers)) {
            throw new errors_1.DependencyIsMissingError(name);
        }
        if (parentDeps.includes(name)) {
            throw new errors_1.CircularDependencyError(name, parentDeps);
        }
        if (this.resolved[name] !== undefined) {
            return this.resolved[name];
        }
        var definition = this.resolvers[name];
        this.resolved[name] = definition.resolve(this, __spreadArray(__spreadArray([], parentDeps, true), [name], false));
        return this.resolved[name];
    };
    /**
     * Adds multiple dependency resolvers to the container
     * @param resolvers - named dependency object
     */
    DIContainer.prototype.add = function (resolvers) {
        var _this = this;
        Object.keys(resolvers).map(function (name) {
            _this.addResolver(name, resolvers[name]);
        });
    };
    /**
     * Adds single dependency definition to the container
     * @param name - string name for the dependency
     * @param resolver - raw value or instance of IDefinition
     */
    DIContainer.prototype.addResolver = function (name, resolver) {
        if (!(resolver instanceof AbstractResolver_1.default)) {
            resolver = new RawValueResolver_1.default(resolver);
        }
        this.resolvers[name] = resolver;
    };
    return DIContainer;
}());
exports.default = DIContainer;
/**
 * Resolves given function parameters
 */
function resolveFunctionParameters(diContainer, parameters, parentDeps) {
    if (parameters === void 0) { parameters = []; }
    if (parentDeps === void 0) { parentDeps = []; }
    return parameters.map(function (parameter) {
        if (parameter instanceof AbstractResolver_1.default) {
            return parameter.resolve(diContainer, parentDeps);
        }
        return parameter;
    });
}
exports.resolveFunctionParameters = resolveFunctionParameters;
//# sourceMappingURL=DIContainer.js.map